name: Deploy Tagflow to VPS

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: deploy-vps
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH password file
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_PASSWORD }}" > ~/.ssh/vps_password
          chmod 600 ~/.ssh/vps_password

      - name: Sync code to VPS
        run: |
          sudo apt-get update && sudo apt-get install -y sshpass rsync

          sshpass -f ~/.ssh/vps_password ssh -o StrictHostKeyChecking=no root@72.60.10.112 "mkdir -p /root/tagflow"

          sshpass -f ~/.ssh/vps_password rsync -avz --delete \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='.turbo' \
            --exclude='dist' \
            --exclude='apps/web/dist' \
            --exclude='apps/api/dist' \
            --exclude='.env' \
            --exclude='.env.local' \
            --exclude='.DS_Store' \
            -e "ssh -o StrictHostKeyChecking=no" \
            ./ root@72.60.10.112:/root/tagflow/

      - name: Deploy to VPS
        uses: appleboy/ssh-action@master
        env:
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
        with:
          host: 72.60.10.112
          username: root
          password: ${{ secrets.VPS_PASSWORD }}
          port: 22
          timeout: 600s
          command_timeout: 600s
          envs: STRIPE_SECRET_KEY,STRIPE_WEBHOOK_SECRET
          script: |
            set -e

            APP_DIR="/root/tagflow"
            cd "$APP_DIR"

            EXISTING_JWT_SECRET=""
            EXISTING_POSTGRES_PASSWORD=""
            EXISTING_STRIPE_SECRET_KEY=""
            EXISTING_STRIPE_WEBHOOK_SECRET=""
            EXISTING_VAPID_PUBLIC_KEY=""
            EXISTING_VAPID_PRIVATE_KEY=""
            EXISTING_VAPID_SUBJECT=""
            EXISTING_EXTERNAL_PORT=""

            if [ -f .env ]; then
              EXISTING_JWT_SECRET=$(grep -E '^JWT_SECRET=' .env | head -1 | cut -d '=' -f2- || true)
              EXISTING_POSTGRES_PASSWORD=$(grep -E '^POSTGRES_PASSWORD=' .env | head -1 | cut -d '=' -f2- || true)
              EXISTING_STRIPE_SECRET_KEY=$(grep -E '^STRIPE_SECRET_KEY=' .env | head -1 | cut -d '=' -f2- || true)
              EXISTING_STRIPE_WEBHOOK_SECRET=$(grep -E '^STRIPE_WEBHOOK_SECRET=' .env | head -1 | cut -d '=' -f2- || true)
              EXISTING_VAPID_PUBLIC_KEY=$(grep -E '^VAPID_PUBLIC_KEY=' .env | head -1 | cut -d '=' -f2- || true)
              EXISTING_VAPID_PRIVATE_KEY=$(grep -E '^VAPID_PRIVATE_KEY=' .env | head -1 | cut -d '=' -f2- || true)
              EXISTING_VAPID_SUBJECT=$(grep -E '^VAPID_SUBJECT=' .env | head -1 | cut -d '=' -f2- || true)
              EXISTING_EXTERNAL_PORT=$(grep -E '^EXTERNAL_PORT=' .env | head -1 | cut -d '=' -f2- || true)
            fi

            JWT_SECRET="${EXISTING_JWT_SECRET:-tagflow-prod-$(date +%s)-$(openssl rand -hex 16)}"
            POSTGRES_PASSWORD="${EXISTING_POSTGRES_PASSWORD:-tagflow_prod_change_me}"
            STRIPE_SECRET_KEY="${EXISTING_STRIPE_SECRET_KEY:-${STRIPE_SECRET_KEY:-sk_live_replace_me}}"
            STRIPE_WEBHOOK_SECRET="${EXISTING_STRIPE_WEBHOOK_SECRET:-${STRIPE_WEBHOOK_SECRET:-whsec_replace_me}}"
            VAPID_PUBLIC_KEY="${EXISTING_VAPID_PUBLIC_KEY:-replace_me}"
            VAPID_PRIVATE_KEY="${EXISTING_VAPID_PRIVATE_KEY:-replace_me}"
            VAPID_SUBJECT="${EXISTING_VAPID_SUBJECT:-mailto:admin@tagflow.shop}"
            EXTERNAL_PORT="${EXISTING_EXTERNAL_PORT:-3180}"

            cat > .env << EOF
            EXTERNAL_PORT=${EXTERNAL_PORT}
            POSTGRES_USER=tagflow
            POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
            POSTGRES_DB=tagflow
            DATABASE_URL=postgresql://tagflow:${POSTGRES_PASSWORD}@db:5432/tagflow
            JWT_SECRET=${JWT_SECRET}
            COOKIE_SECURE=true
            VITE_API_URL=https://tagflow.shop
            PUBLIC_APP_URL=https://tagflow.shop
            CORS_ORIGIN=https://tagflow.shop,https://www.tagflow.shop
            VAPID_PUBLIC_KEY=${VAPID_PUBLIC_KEY}
            VAPID_PRIVATE_KEY=${VAPID_PRIVATE_KEY}
            VAPID_SUBJECT=${VAPID_SUBJECT}
            STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY}
            STRIPE_WEBHOOK_SECRET=${STRIPE_WEBHOOK_SECRET}
            LOG_LEVEL=debug
            VITE_LOG_LEVEL=warn
            BUILD_DATE=\$(date +%Y%m%d%H%M%S)
            EOF

            # Parar e remover containers antigos preservando volumes
            echo "Stopping existing containers..."
            docker-compose -f docker-compose.vps.yml down --remove-orphans || true

            # Remover imagens antigas para forçar rebuild completo
            echo "Removing old images..."
            docker rmi tagflow-nginx tagflow-web tagflow-api 2>/dev/null || true

            # Limpar imagens dangling
            docker image prune -f || true

            # Build completo sem cache (com timestamp no label para garantir rebuild)
            echo "Building new images..."
            docker-compose -f docker-compose.vps.yml build --no-cache --pull \
              --build-arg BUILD_DATE="$(date +%Y%m%d%H%M%S)"

            # Subir containers com força de recreação
            echo "Starting containers..."
            docker-compose -f docker-compose.vps.yml up -d --force-recreate --remove-orphans

            # Aguardar healthchecks dos containers
            echo "Waiting for containers to be healthy..."
            for i in {1..60}; do
              HEALTHY=$(docker-compose -f docker-compose.vps.yml ps --format json | jq -r 'select(.Health=="healthy") | .Name' | wc -l)
              TOTAL=$(docker-compose -f docker-compose.vps.yml ps --format json | wc -l)
              echo "Healthy: $HEALTHY/$TOTAL containers"
              if [ "$HEALTHY" -eq "$TOTAL" ]; then
                echo "All containers are healthy!"
                break
              fi
              sleep 2
            done

            for i in {1..30}; do
              DB_CONTAINER=$(docker-compose -f docker-compose.vps.yml ps -q db || true)
              if [ -n "$DB_CONTAINER" ]; then
                break
              fi
              echo "Container do banco nao encontrado."
              sleep 2
            done

            if [ -z "$DB_CONTAINER" ]; then
              echo "Container do banco nao encontrado."
              docker-compose -f docker-compose.vps.yml ps
              exit 1
            fi

            for i in {1..30}; do
              if docker exec -i "$DB_CONTAINER" pg_isready -U tagflow -d tagflow >/dev/null 2>&1; then
                break
              fi
              echo "Banco nao ficou pronto a tempo."
              sleep 2
            done

            if ! docker exec -i "$DB_CONTAINER" pg_isready -U tagflow -d tagflow >/dev/null 2>&1; then
              echo "Banco nao ficou pronto a tempo."
              docker logs "$DB_CONTAINER" --tail=200 || true
              exit 1
            fi

            docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -v ON_ERROR_STOP=1 \
              -c "CREATE TABLE IF NOT EXISTS schema_migrations (filename text primary key, applied_at timestamptz default now());"

            MIGRATIONS_DIR="${APP_DIR}/apps/api/drizzle"
            echo "Migrations disponiveis:"
            ls -1 "${MIGRATIONS_DIR}" || true
            for file in $(ls -1 ${MIGRATIONS_DIR}/[0-9][0-9][0-9][0-9]_*.sql 2>/dev/null | sort); do
              fname=$(basename "$file")
              applied=$(docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -t -c "SELECT 1 FROM schema_migrations WHERE filename='${fname}';" | tr -d '[:space:]')
              if [ -z "$applied" ]; then
                echo "Aplicando migration ${fname}..."
                docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -v ON_ERROR_STOP=1 < "$file"
                docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -v ON_ERROR_STOP=1 \
                  -c "INSERT INTO schema_migrations (filename) VALUES ('${fname}');"
              fi
            done

            GLOBAL_TABLE_EXISTS=$(docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -t -c "SELECT 1 FROM information_schema.tables WHERE table_name='global_customers';" | tr -d '[:space:]')
            GLOBAL_COLUMN_EXISTS=$(docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -t -c "SELECT 1 FROM information_schema.columns WHERE table_name='customers' AND column_name='global_customer_id';" | tr -d '[:space:]')
            if [ -z "$GLOBAL_TABLE_EXISTS" ] || [ -z "$GLOBAL_COLUMN_EXISTS" ]; then
              echo "Aplicando migration global de clientes manualmente..."
              docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -v ON_ERROR_STOP=1 < "${MIGRATIONS_DIR}/0012_global_customers.sql"
              docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -v ON_ERROR_STOP=1 \
                -c "INSERT INTO schema_migrations (filename) VALUES ('0012_global_customers.sql') ON CONFLICT DO NOTHING;"
            fi

            SEED_COUNT=$(docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -t -c "SELECT COUNT(*) FROM companies;" | tr -d '[:space:]' || echo "0")
            if [ -z "$SEED_COUNT" ] || [ "$SEED_COUNT" = "0" ]; then
              echo "Executando seed inicial..."
              docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -v ON_ERROR_STOP=1 < "${MIGRATIONS_DIR}/seed.sql"
            fi

            PLANS_COUNT=$(docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -t -c "SELECT COUNT(*) FROM plans;" | tr -d '[:space:]' || echo "0")
            if [ -z "$PLANS_COUNT" ] || [ "$PLANS_COUNT" = "0" ]; then
              echo "Inserindo planos padrao..."
              docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -v ON_ERROR_STOP=1 < "${MIGRATIONS_DIR}/seed_plans.sql"
            fi

            API_CONTAINER=$(docker-compose -f docker-compose.vps.yml ps -q api || true)
            if [ -n "$API_CONTAINER" ]; then
              echo "Executando migracao global de clientes..."
              docker exec -i "$API_CONTAINER" bun /app/src/scripts/migrateGlobalCustomers.ts || echo "Aviso: migracao global falhou"
            else
              echo "Container da API nao encontrado para migracao global."
            fi

            # Configure host nginx as reverse proxy to container
            echo "Configuring host nginx..."
            UPSTREAM_IP="127.0.0.1"
            UPSTREAM_PORT="${EXTERNAL_PORT}"

            NGINX_CONF="/etc/nginx/sites-available/tagflow.conf"
            NGINX_BACKUP="/etc/nginx/sites-available/tagflow.conf.bak"

            # Backup existing config
            if [ -f "$NGINX_CONF" ]; then
              cp "$NGINX_CONF" "$NGINX_BACKUP"
            fi

            # Check SSL certificate status
            CERT_VALID=false
            if [ -f /etc/letsencrypt/live/tagflow.shop/fullchain.pem ]; then
              if openssl x509 -in /etc/letsencrypt/live/tagflow.shop/fullchain.pem -noout -checkend 604800 2>/dev/null; then
                echo "Valid SSL certificate found (expires in >7 days)"
                CERT_VALID=true
              else
                echo "Certificate expiring soon or invalid"
              fi
            fi

            # Obtain/renew SSL certificate if needed
            if [ "$CERT_VALID" = "false" ]; then
              echo "Obtaining SSL certificate..."
              systemctl stop nginx || true
              sleep 2

              certbot certonly --standalone --preferred-challenges http \
                -d tagflow.shop -d www.tagflow.shop \
                --non-interactive --agree-tos \
                --email admin@tagflow.shop \
                --cert-name tagflow.shop || {
                  echo "WARNING: SSL certificate installation failed"
                  echo "Falling back to HTTP-only mode"
                  CERT_VALID=false
              }

              if [ -f /etc/letsencrypt/live/tagflow.shop/fullchain.pem ]; then
                CERT_VALID=true
              fi
            fi

            # Create nginx configuration (HTTP or HTTPS based on cert availability)
            if [ "$CERT_VALID" = "true" ]; then
              echo "Creating HTTPS nginx configuration..."
              cat > "$NGINX_CONF" << 'NGINX_HTTPS_EOF'
            server {
                listen 80;
                listen [::]:80;
                server_name tagflow.shop www.tagflow.shop;
                return 301 https://$server_name$request_uri;
            }

            server {
                listen 443 ssl http2;
                listen [::]:443 ssl http2;
                server_name tagflow.shop www.tagflow.shop;

                ssl_certificate /etc/letsencrypt/live/tagflow.shop/fullchain.pem;
                ssl_certificate_key /etc/letsencrypt/live/tagflow.shop/privkey.pem;
                ssl_protocols TLSv1.2 TLSv1.3;
                ssl_ciphers HIGH:!aNULL:!MD5;
                ssl_prefer_server_ciphers on;
                ssl_stapling on;
                ssl_stapling_verify on;

                access_log /var/log/nginx/tagflow-access.log;
                error_log /var/log/nginx/tagflow-error.log;

                client_max_body_size 50M;

                location /api/ {
                    proxy_pass http://UPSTREAM_PLACEHOLDER/api/;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection "upgrade";
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                    proxy_connect_timeout 60s;
                    proxy_send_timeout 60s;
                    proxy_read_timeout 60s;
                }

                location /health {
                    proxy_pass http://UPSTREAM_PLACEHOLDER/health;
                    proxy_http_version 1.1;
                    proxy_set_header Host $host;
                }

                location / {
                    proxy_pass http://UPSTREAM_PLACEHOLDER/;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection "upgrade";
                    proxy_set_header Host $host;
                    proxy_cache_bypass $http_upgrade;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
            }
            NGINX_HTTPS_EOF
              sed -i "s|UPSTREAM_PLACEHOLDER|${UPSTREAM_IP}:${UPSTREAM_PORT}|g" "$NGINX_CONF"
            else
              echo "Creating HTTP-only nginx configuration..."
              cat > "$NGINX_CONF" << 'NGINX_HTTP_EOF'
            server {
                listen 80;
                listen [::]:80;
                server_name tagflow.shop www.tagflow.shop;

                access_log /var/log/nginx/tagflow-access.log;
                error_log /var/log/nginx/tagflow-error.log;

                client_max_body_size 50M;

                location /api/ {
                    proxy_pass http://UPSTREAM_PLACEHOLDER/api/;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection "upgrade";
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }

                location /health {
                    proxy_pass http://UPSTREAM_PLACEHOLDER/health;
                    proxy_http_version 1.1;
                    proxy_set_header Host $host;
                }

                location / {
                    proxy_pass http://UPSTREAM_PLACEHOLDER/;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection "upgrade";
                    proxy_set_header Host $host;
                    proxy_cache_bypass $http_upgrade;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
            }
            NGINX_HTTP_EOF
              sed -i "s|UPSTREAM_PLACEHOLDER|${UPSTREAM_IP}:${UPSTREAM_PORT}|g" "$NGINX_CONF"
            fi

            # Enable configuration
            rm -f /etc/nginx/sites-enabled/default
            ln -sf "$NGINX_CONF" /etc/nginx/sites-enabled/tagflow.conf

            # Test nginx configuration - isolate tagflow.conf test
            echo "Testing nginx configuration..."
            NGINX_TEST_PASSED=false
            if nginx -t 2>&1 | grep -q "syntax is ok"; then
              echo "Nginx test passed"
              NGINX_TEST_PASSED=true
            else
              echo "WARNING: Global nginx test failed (may be due to other sites)"
              echo "Attempting isolated test of tagflow.conf..."

              # Try to identify if error is in tagflow.conf specifically
              if nginx -t 2>&1 | grep -q "tagflow.conf"; then
                echo "ERROR: Problem detected in tagflow.conf"
                if [ -f "$NGINX_BACKUP" ]; then
                  echo "Restoring backup configuration"
                  cp "$NGINX_BACKUP" "$NGINX_CONF"
                fi
              else
                echo "Error is in other site configs, tagflow.conf is OK"
                NGINX_TEST_PASSED=true
              fi
            fi

            # Reload nginx
            if [ "$NGINX_TEST_PASSED" = "true" ]; then
              if systemctl is-active --quiet nginx; then
                systemctl reload nginx && echo "Nginx reloaded successfully"
              else
                systemctl start nginx && echo "Nginx started successfully"
              fi
            else
              echo "WARNING: Skipping nginx reload due to config errors"
              echo "Application still accessible on http://localhost:${EXTERNAL_PORT}"
            fi

            # Final health check with retry
            echo "Performing final health check..."
            HEALTH_OK=false
            for i in {1..30}; do
              if curl -f -s http://localhost:${EXTERNAL_PORT}/health | grep -q "ok"; then
                echo "Health check passed!"
                HEALTH_OK=true
                break
              fi
              echo "Attempt $i/30: Health check not ready yet..."
              sleep 2
            done

            if [ "$HEALTH_OK" = "false" ]; then
              echo "ERROR: Health check failed after 60 seconds"
              echo "Container status:"
              docker-compose -f docker-compose.vps.yml ps
              echo ""
              echo "Recent logs:"
              docker-compose -f docker-compose.vps.yml logs --tail=100
              exit 1
            fi

            # Verify HTTPS if certificate exists
            if [ "$CERT_VALID" = "true" ]; then
              echo "Verifying HTTPS access..."
              if curl -f -s -k https://localhost/health | grep -q "ok"; then
                echo "HTTPS is working correctly"
              else
                echo "WARNING: HTTPS verification failed, but HTTP is working"
              fi
            fi

            echo ""
            echo "=========================================="
            echo "Deploy completed successfully!"
            echo "=========================================="
            echo "Application URLs:"
            if [ "$CERT_VALID" = "true" ]; then
              echo "  - https://tagflow.shop"
              echo "  - https://www.tagflow.shop"
            else
              echo "  - http://tagflow.shop"
              echo "  - http://www.tagflow.shop"
            fi
            echo "Direct container access: http://localhost:${EXTERNAL_PORT}"
            echo "=========================================="

      - name: Verify Deployment
        if: success()
        run: |
          echo "Deploy concluido com sucesso!"
          echo "Tagflow disponivel em:"
          echo "   - https://tagflow.shop"
          echo "   - https://www.tagflow.shop"
          echo "Health check: https://tagflow.shop/health"

