name: Deploy Tagflow to VPS

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: deploy-vps
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH password file
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_PASSWORD }}" > ~/.ssh/vps_password
          chmod 600 ~/.ssh/vps_password

      - name: Sync code to VPS
        run: |
          sudo apt-get update && sudo apt-get install -y sshpass rsync

          sshpass -f ~/.ssh/vps_password ssh -o StrictHostKeyChecking=no root@72.60.10.112 "mkdir -p /root/tagflow"

          sshpass -f ~/.ssh/vps_password rsync -avz --delete \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='.turbo' \
            --exclude='dist' \
            --exclude='apps/web/dist' \
            --exclude='apps/api/dist' \
            --exclude='.env' \
            --exclude='.env.local' \
            --exclude='.DS_Store' \
            -e "ssh -o StrictHostKeyChecking=no" \
            ./ root@72.60.10.112:/root/tagflow/

      - name: Deploy to VPS
        uses: appleboy/ssh-action@master
        with:
          host: 72.60.10.112
          username: root
          password: ${{ secrets.VPS_PASSWORD }}
          port: 22
          timeout: 600s
          command_timeout: 600s
          script: |
            set -e

            APP_DIR="/root/tagflow"
            cd "$APP_DIR"

            EXISTING_JWT_SECRET=""
            EXISTING_POSTGRES_PASSWORD=""
            EXISTING_STRIPE_SECRET_KEY=""
            EXISTING_STRIPE_WEBHOOK_SECRET=""
            EXISTING_VAPID_PUBLIC_KEY=""
            EXISTING_VAPID_PRIVATE_KEY=""
            EXISTING_VAPID_SUBJECT=""

            if [ -f .env ]; then
              EXISTING_JWT_SECRET=$(grep -E '^JWT_SECRET=' .env | head -1 | cut -d '=' -f2- || true)
              EXISTING_POSTGRES_PASSWORD=$(grep -E '^POSTGRES_PASSWORD=' .env | head -1 | cut -d '=' -f2- || true)
              EXISTING_STRIPE_SECRET_KEY=$(grep -E '^STRIPE_SECRET_KEY=' .env | head -1 | cut -d '=' -f2- || true)
              EXISTING_STRIPE_WEBHOOK_SECRET=$(grep -E '^STRIPE_WEBHOOK_SECRET=' .env | head -1 | cut -d '=' -f2- || true)
              EXISTING_VAPID_PUBLIC_KEY=$(grep -E '^VAPID_PUBLIC_KEY=' .env | head -1 | cut -d '=' -f2- || true)
              EXISTING_VAPID_PRIVATE_KEY=$(grep -E '^VAPID_PRIVATE_KEY=' .env | head -1 | cut -d '=' -f2- || true)
              EXISTING_VAPID_SUBJECT=$(grep -E '^VAPID_SUBJECT=' .env | head -1 | cut -d '=' -f2- || true)
            fi

            JWT_SECRET="${EXISTING_JWT_SECRET:-tagflow-prod-$(date +%s)-$(openssl rand -hex 16)}"
            POSTGRES_PASSWORD="${EXISTING_POSTGRES_PASSWORD:-tagflow_prod_change_me}"
            STRIPE_SECRET_KEY="${EXISTING_STRIPE_SECRET_KEY:-sk_live_replace_me}"
            STRIPE_WEBHOOK_SECRET="${EXISTING_STRIPE_WEBHOOK_SECRET:-whsec_replace_me}"
            VAPID_PUBLIC_KEY="${EXISTING_VAPID_PUBLIC_KEY:-replace_me}"
            VAPID_PRIVATE_KEY="${EXISTING_VAPID_PRIVATE_KEY:-replace_me}"
            VAPID_SUBJECT="${EXISTING_VAPID_SUBJECT:-mailto:admin@tagflow.shop}"

            cat > .env << EOF
            EXTERNAL_PORT=3180
            POSTGRES_USER=tagflow
            POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
            POSTGRES_DB=tagflow
            DATABASE_URL=postgresql://tagflow:${POSTGRES_PASSWORD}@db:5432/tagflow
            JWT_SECRET=${JWT_SECRET}
            COOKIE_SECURE=true
            VITE_API_URL=https://tagflow.shop
            PUBLIC_APP_URL=https://tagflow.shop
            CORS_ORIGIN=https://tagflow.shop,https://www.tagflow.shop
            VAPID_PUBLIC_KEY=${VAPID_PUBLIC_KEY}
            VAPID_PRIVATE_KEY=${VAPID_PRIVATE_KEY}
            VAPID_SUBJECT=${VAPID_SUBJECT}
            STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY}
            STRIPE_WEBHOOK_SECRET=${STRIPE_WEBHOOK_SECRET}
            EOF

            docker-compose -f docker-compose.vps.yml down --remove-orphans || true
            docker-compose -f docker-compose.vps.yml build --no-cache --pull
            docker-compose -f docker-compose.vps.yml up -d --remove-orphans

            for i in {1..30}; do
              DB_CONTAINER=$(docker-compose -f docker-compose.vps.yml ps -q db || true)
              if [ -n "$DB_CONTAINER" ]; then
                break
              fi
              echo "Aguardando container do banco..."
              sleep 2
            done

            if [ -z "$DB_CONTAINER" ]; then
              echo "Container do banco n√£o encontrado."
              docker-compose -f docker-compose.vps.yml ps
              exit 1
            fi

            for i in {1..30}; do
              if docker exec -i "$DB_CONTAINER" pg_isready -U tagflow -d tagflow >/dev/null 2>&1; then
                break
              fi
              echo "Aguardando banco ficar pronto..."
              sleep 2
            done

            if ! docker exec -i "$DB_CONTAINER" pg_isready -U tagflow -d tagflow >/dev/null 2>&1; then
              echo "Banco n√£o ficou pronto a tempo."
              docker logs "$DB_CONTAINER" --tail=200 || true
              exit 1
            fi

            docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -v ON_ERROR_STOP=1 \
              -c "CREATE TABLE IF NOT EXISTS schema_migrations (filename text primary key, applied_at timestamptz default now());"

            MIGRATIONS_DIR="${APP_DIR}/apps/api/drizzle"
            for file in $(ls -1 ${MIGRATIONS_DIR}/[0-9][0-9][0-9][0-9]_*.sql 2>/dev/null | sort); do
              fname=$(basename "$file")
              applied=$(docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -t -c "SELECT 1 FROM schema_migrations WHERE filename='${fname}';" | tr -d '[:space:]')
              if [ -z "$applied" ]; then
                echo "Aplicando migration ${fname}..."
                docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -v ON_ERROR_STOP=1 < "$file"
                docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -v ON_ERROR_STOP=1 \
                  -c "INSERT INTO schema_migrations (filename) VALUES ('${fname}');"
              fi
            done

            SEED_COUNT=$(docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -t -c "SELECT COUNT(*) FROM companies;" | tr -d '[:space:]' || echo "0")
            if [ -z "$SEED_COUNT" ] || [ "$SEED_COUNT" = "0" ]; then
              echo "Executando seed inicial..."
              docker exec -i "$DB_CONTAINER" psql -U tagflow -d tagflow -v ON_ERROR_STOP=1 < "${MIGRATIONS_DIR}/seed.sql"
            fi

            # Resolve upstream for host nginx (docker IP preferred)
            NGINX_CONTAINER=$(docker-compose -f docker-compose.vps.yml ps -q nginx || true)
            UPSTREAM_IP=""
            if [ -n "$NGINX_CONTAINER" ]; then
              UPSTREAM_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$NGINX_CONTAINER" 2>/dev/null || echo "")
            fi
            if [ -z "$UPSTREAM_IP" ]; then
              UPSTREAM_IP="127.0.0.1"
              UPSTREAM_PORT="3180"
            else
              UPSTREAM_PORT="80"
            fi

            # Create initial HTTP-only nginx config
            cat > /etc/nginx/conf.d/tagflow.conf << NGINX_EOF
            server {
                listen 80;
                listen [::]:80;
                server_name tagflow.shop www.tagflow.shop;

                access_log /var/log/nginx/tagflow-access.log;
                error_log /var/log/nginx/tagflow-error.log;

                client_max_body_size 50M;

                location /api/ {
                    proxy_pass http://${UPSTREAM_IP}:${UPSTREAM_PORT}/api/;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection "upgrade";
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }

                location /health {
                    proxy_pass http://${UPSTREAM_IP}:${UPSTREAM_PORT}/health;
                    proxy_http_version 1.1;
                    proxy_set_header Host $host;
                }

                location / {
                    proxy_pass http://${UPSTREAM_IP}:${UPSTREAM_PORT}/;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection "upgrade";
                    proxy_set_header Host $host;
                    proxy_cache_bypass $http_upgrade;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
            }
            NGINX_EOF

            # Remove conflicting configs
            rm -f /etc/nginx/sites-enabled/tagflow.conf
            rm -f /etc/nginx/sites-enabled/default

            # Test and reload nginx (ignore errors from other sites)
            if nginx -t 2>&1 | grep -q "test failed"; then
              echo "Warning: nginx test failed, but continuing (likely due to other sites SSL issues)"
            fi
            systemctl reload nginx || echo "Warning: nginx reload had issues"

            # Check if SSL certificate exists and is valid
            CERT_EXISTS=false
            if [ -f /etc/letsencrypt/live/tagflow.shop/fullchain.pem ]; then
              if openssl x509 -in /etc/letsencrypt/live/tagflow.shop/fullchain.pem -noout -text | grep -q "tagflow.shop"; then
                echo "‚úÖ Valid SSL certificate found for tagflow.shop"
                CERT_EXISTS=true
              else
                echo "‚ö†Ô∏è  Certificate exists but is not for tagflow.shop, removing..."
                rm -rf /etc/letsencrypt/live/tagflow.shop
                rm -rf /etc/letsencrypt/archive/tagflow.shop
                rm -f /etc/letsencrypt/renewal/tagflow.shop.conf
              fi
            fi

            # Install SSL certificate if not exists or invalid
            if [ "$CERT_EXISTS" = "false" ]; then
              echo "Installing SSL certificate with certbot..."

              # Stop nginx to free port 80 for certbot
              systemctl stop nginx
              sleep 2

              # Verify port 80 is free
              if netstat -tlnp | grep ':80 '; then
                echo "‚ùå Port 80 is still in use!"
                netstat -tlnp | grep ':80 '
                systemctl start nginx
                exit 1
              fi

              # Use certbot standalone mode to avoid nginx conflicts
              echo "Running certbot for tagflow.shop and www.tagflow.shop..."
              if certbot certonly --standalone --preferred-challenges http \
                -d tagflow.shop -d www.tagflow.shop \
                --non-interactive \
                --agree-tos \
                --email admin@tagflow.shop \
                --cert-name tagflow.shop; then
                echo "‚úÖ SSL certificate installed successfully"
              else
                echo "‚ùå Failed to install SSL certificate"
                cat /var/log/letsencrypt/letsencrypt.log | tail -50
                systemctl start nginx
                exit 1
              fi

              # Verify certificate was created
              if [ ! -f /etc/letsencrypt/live/tagflow.shop/fullchain.pem ]; then
                echo "‚ùå Certificate file not found after certbot"
                ls -la /etc/letsencrypt/live/ || true
                systemctl start nginx
                exit 1
              fi
            fi

            # Always update nginx config with SSL (whether cert was just installed or already existed)
            echo "Configuring nginx with SSL..."
              cat > /etc/nginx/conf.d/tagflow.conf << NGINX_EOF
              server {
                  listen 80;
                  listen [::]:80;
                  server_name tagflow.shop www.tagflow.shop;
                  return 301 https://$host$request_uri;
              }

              server {
                  listen 443 ssl http2;
                  listen [::]:443 ssl http2;
                  server_name tagflow.shop www.tagflow.shop;

                  ssl_certificate /etc/letsencrypt/live/tagflow.shop/fullchain.pem;
                  ssl_certificate_key /etc/letsencrypt/live/tagflow.shop/privkey.pem;
                  ssl_protocols TLSv1.2 TLSv1.3;
                  ssl_ciphers HIGH:!aNULL:!MD5;
                  ssl_prefer_server_ciphers on;

                  access_log /var/log/nginx/tagflow-access.log;
                  error_log /var/log/nginx/tagflow-error.log;

                  client_max_body_size 50M;

                  location /api/ {
                      proxy_pass http://${UPSTREAM_IP}:${UPSTREAM_PORT}/api/;
                      proxy_http_version 1.1;
                      proxy_set_header Upgrade $http_upgrade;
                      proxy_set_header Connection "upgrade";
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                  }

                  location /health {
                      proxy_pass http://${UPSTREAM_IP}:${UPSTREAM_PORT}/health;
                      proxy_http_version 1.1;
                      proxy_set_header Host $host;
                  }

                  location / {
                      proxy_pass http://${UPSTREAM_IP}:${UPSTREAM_PORT}/;
                      proxy_http_version 1.1;
                      proxy_set_header Upgrade $http_upgrade;
                      proxy_set_header Connection "upgrade";
                      proxy_set_header Host $host;
                      proxy_cache_bypass $http_upgrade;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                  }
              }
              NGINX_EOF

              # Test nginx config before starting
              if ! nginx -t; then
                echo "‚ùå Nginx config test failed"
                exit 1
              fi

              # Start nginx with new SSL config
              systemctl start nginx
              sleep 2

              # Verify nginx started successfully
              if ! systemctl is-active --quiet nginx; then
                echo "‚ùå Nginx failed to start with SSL config"
                systemctl status nginx
                journalctl -u nginx -n 50
                exit 1
              fi

              # Verify SSL is working
              echo "Testing SSL certificate..."
              if curl -k -I https://localhost 2>&1 | grep -q "HTTP"; then
                echo "‚úÖ HTTPS is responding"
              else
                echo "‚ùå HTTPS is not responding"
                exit 1
              fi

              echo "‚úÖ Nginx restarted with SSL configuration"

            echo "Aguardando inicializa√ß√£o..."
            sleep 15

            if ! curl -f http://localhost:3180/health >/dev/null 2>&1; then
              echo "Health check falhou."
              docker-compose -f docker-compose.vps.yml logs --tail=200
              exit 1
            fi

      - name: Verify Deployment
        if: success()
        run: |
          echo "‚úÖ Deploy conclu√≠do com sucesso!"
          echo "üåê Tagflow dispon√≠vel em:"
          echo "   - https://tagflow.shop"
          echo "   - https://www.tagflow.shop"
          echo "üìä Health check: https://tagflow.shop/health"
